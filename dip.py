# -*- coding: utf-8 -*-
"""DIP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yy9btr53jBt0ImmJUGstzatxM49R6F6G
"""

from PIL import Image, ImageFilter
import numpy as np
def darkprior(img, patch_size = 7):
  #for some padding size, as specified in the Single Image Haze Removal Using Dark Channel Prior, best results are shown on 15, given here default 
  #for this image, divide it into 3 different matrices RGB and then do the padding of half of the patch_size
  
  temp = np.array(img)
  [n,m,l] = temp.shape
  pad_size = int(patch_size)
  R = temp[:,:,0]
  G = temp[:,:,1]
  B = temp[:,:,2]
  #now do the padding thing
  R = np.pad(R, pad_width=pad_size, mode='constant', constant_values = float('inf'))
  G = np.pad(G, pad_width=pad_size, mode='constant', constant_values = float('inf'))
  B = np.pad(B, pad_width=pad_size, mode='constant', constant_values = float('inf'))

  #After padding, we have to take the min of each window size 
  dark = np.zeros([n,m])
  for i in range(n):
    for j in range(m):
      #window indices start from (i,j) to (i+patch_size), (j+patch_size)
      #scrap the matrices
      r = R[i:i+patch_size+1, j:j+patch_size+1]
      g = G[i:i+patch_size+1, j:j+patch_size+1]
      b = B[i:i+patch_size+1, j:j+patch_size+1]
      dark[i][j] = min(r.min(), g.min(), b.min())
  # dark = np.divide(dark, 255.0)
  return dark
      


# print(np.array(img).shape)

#Read the image and pass it into dark channel
import matplotlib.pyplot as plt
image=cv2.imread('/content/cones.jpg')

dark = darkprior(image)
plt.imshow(dark, cmap = 'gray')
plt.show()
plt.imshow(image[:,:,::-1])

dark = np.array(dark)
print(dark)
# print(np.array(dark))

def compute_atmosphere_light(img,dark_channel_img):
    h,w=dark_channel_img.shape[:2]
    num_of_candiate=int(0.001*h*w)
    dark_channel=dark_channel_img.reshape(-1,1)[:,0] #flatten
    arg_sorted=np.argsort(dark_channel)[::-1] #reverse sort
    img=img.astype(np.float32)
    atmosphere_light=np.zeros((3,)) #empty holder
    for i in range(num_of_candiate):
        index=arg_sorted[i]
        row_index=index//w
        col_index=index%w
        for c in range(3):
            atmosphere_light[c]=max(atmosphere_light[c],img[row_index,col_index][c])
    return atmosphere_light
A=compute_atmosphere_light(image,dark)
print(A)

#function for Transmission estimate 
def transmission_estimate(img, A, dark, guided_filter_radius=50,epsilon=0.0001):
  #open the image
  img_gray=cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  img = np.array(img).astype('float')
  #convert it into numpy array
  # img = np.array(img)
  # img[:,:,0] = img[:,:,0]/A
  # img[:,:,1] = img[:,:,1]/A
  # img[:,:,2] = img[:,:,2]/A
  # print(img.shape)
  dark = dark/A

  zero_mat=np.zeros((img.shape[0],img.shape[1]))
  transmition_rate_est = cv2.max(zero_mat,np.ones_like(zero_mat) -0.95*dark)
  transmission_rate=cv2.ximgproc.guidedFilter(img_gray.astype(np.float32),transmition_rate_est.astype(np.float32),guided_filter_radius,epsilon)
  return transmission_rate
  


transmission_rate=transmission_estimate(image,np.max(A), dark)
plt.title('transmission_rate')
plt.axis('off')
plt.imshow(transmission_rate,cmap='gray')
plt.show()

min_transmission=0.1
transmission_rate[transmission_rate<min_transmission]=min_transmission
dehaze_img=np.zeros_like(image,dtype=np.uint8)

for c in range(3):
    dehaze_img[:,:,c]=(image[:,:,c]-A[c])/transmission_rate+A[c]
dehaze_img[dehaze_img>255]=255
dehaze_img[dehaze_img<0]=0
plt.title('dehaze')
plt.axis('off')
plt.imshow(dehaze_img[:,:,::-1])

